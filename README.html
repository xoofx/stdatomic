<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-10-02 Mo 17:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>An implementation of the C11 <code>&lt;stdatomic.h&gt;</code> interface</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Jens Gustedt" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="./org-style.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">An implementation of the C11 <code>&lt;stdatomic.h&gt;</code> interface</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org585146f">1. Implemented library features</a>
<ul>
<li><a href="#org7dfc23a">1.1. Type, constants and function interfaces</a></li>
<li><a href="#orgcc51336">1.2. Type generic functions</a>
<ul>
<li><a href="#org45188fa">1.2.1. The <code>__atomic_</code> ABI</a></li>
<li><a href="#org766a4c8">1.2.2. Clang's <code>__c11_atomic</code> built-ins</a></li>
<li><a href="#org3e7c0bc">1.2.3. The <code>__sync</code> ABI</a></li>
<li><a href="#org4061aec">1.2.4. The lock-full fallback functions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org83eb2c0">2. The <code>&lt;stdatomic.h&gt;</code> header file</a>
<ul>
<li><a href="#org984beae">2.1. Full C11 support</a></li>
<li><a href="#org2bd715e">2.2. Partial C11 atomics support</a>
<ul>
<li><a href="#org9d2a801">2.2.1. Issues</a></li>
</ul>
</li>
<li><a href="#org073982d">2.3. Basic atomics support</a></li>
</ul>
</li>
<li><a href="#orge20f3b4">3. The implementation</a>
<ul>
<li><a href="#org6e1eb2b">3.1. Requirements</a>
<ul>
<li><a href="#orgb247dbc">3.1.1. Compilers</a></li>
<li><a href="#org925280b">3.1.2. OS or C library support</a></li>
</ul>
</li>
<li><a href="#orgfcc19af">3.2. Caveats</a>
<ul>
<li><a href="#org8bf8447">3.2.1. Symbol renaming</a></li>
<li><a href="#org3b3847e">3.2.2. Support of 16 byte atomic instructions</a></li>
</ul>
</li>
<li><a href="#org4471767">3.3. Leftovers</a></li>
<li><a href="#org3ba7905">3.4. Instrumentation and testing</a>
<ul>
<li><a href="#org2c0cb70">3.4.1. Instrumentation</a></li>
<li><a href="#org6551fc4">3.4.2. Code injection</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc15658d">4. Performance considerations</a>
<ul>
<li><a href="#orgeb79bad">4.1. Benchmarks</a></li>
<li><a href="#orgc872799">4.2. Code inspection</a>
<ul>
<li><a href="#orgf939df7">4.2.1. Lower range of thread numbers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2a1e813">5. Installation</a>
<ul>
<li><a href="#org37ba3d9">5.1. Musl</a>
<ul>
<li><a href="#org1904c1b">5.1.1. direct integration</a></li>
<li><a href="#org5176ff3">5.1.2. building externally</a></li>
</ul>
</li>
<li><a href="#org9a45e07">5.2. Other C libraries</a></li>
</ul>
</li>
<li><a href="#org9596efb">6. Terms</a>
<ul>
<li><a href="#orgb720cba">6.1. Copyright and License</a></li>
<li><a href="#org5a61a26">6.2. Distribution</a></li>
</ul>
</li>
</ul>
</div>
</div>
<h1 align="center" >Jens Gustedt</h1>
<div class="ABSTRACT">
<p>
The implementation of the C11 atomic interface typically sits
between the implementation of the core language by the C compiler
and the implementation of the C library. It needs compiler support
for the individual atomic operations and library supports for the
cases where no low-level atomic instruction is available and a lock
must be taken.
</p>

<ul class="org-ul">
<li>This implementation builds entirely on the two gcc ABIs for
atomics. It doesn't even attempt to go down to assembly level by
itself.</li>

<li>We provide all function interfaces that the two gcc ABIs and the
C standard need.</li>

<li>For compilers that don't offer the direct language support for
atomics this provides a syntactically reduced but fully functional
approach to atomic operations.</li>
</ul>

<p>
The sources of this library can be found at
<a href="https://gforge.inria.fr/projects/stdatomic">https://gforge.inria.fr/projects/stdatomic</a>
</p>

<p>
A short description of the new futex-lock algorithm that is
implemented for the Linux operating system has been accepted for
SAC'16. A long version of that article can be found here:
<a href="https://hal.inria.fr/hal-01236734">https://hal.inria.fr/hal-01236734</a>
</p>

</div>

<div id="outline-container-org585146f" class="outline-2">
<h2 id="org585146f"><span class="section-number-2">1</span> Implemented library features</h2>
<div class="outline-text-2" id="text-1">
<p>
We distinguish between the implementation of library functions and
the <code>&lt;stdatomic.h&gt;</code> header file.
</p>

<p>
The latter already contains a lot of intelligence, because it has
to provide type generic interfaces. This is more involved than usual C
library header files.
</p>

<p>
The header file is optional, the created function interface should
be compatible with the header files that gcc and clang may provide.
</p>

<p>
But you should be careful with gcc's header file. Up to now
(Dec 2015) that header file has an unfixed bug: addition and
subtraction of atomic types only does the increments in bytes, and
not in elements of the base type of the pointer. Avoid their
header, as long as this bug isn't fixed.  If you are interested you
can follow their bug at
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64843">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64843</a>
</p>
</div>

<div id="outline-container-org7dfc23a" class="outline-3">
<h3 id="org7dfc23a"><span class="section-number-3">1.1</span> Type, constants and function interfaces</h3>
<div class="outline-text-3" id="text-1-1">
<p>
These are the types and proper functions that are foreseen by the
standard:
</p>

<ul class="org-ul">
<li><code>atomic_flag</code> and its four functions</li>
<li>the <code>memory_order</code> enumeration type</li>
<li>fences</li>
<li>object-like macros to test for lock-freeness and similar things</li>
<li><code>typedef</code> for atomic integer and pointer types.</li>
</ul>

<p>
All of these are provided in forms that are compatible with gcc and
clang.
</p>
</div>
</div>

<div id="outline-container-orgcc51336" class="outline-3">
<h3 id="orgcc51336"><span class="section-number-3">1.2</span> Type generic functions</h3>
<div class="outline-text-3" id="text-1-2">
<p>
These are all implemented as macros, and should in many cases
result in optimized inlined assembler instructions, and not in
library calls. Library calls are only needed as fall back, when
there is no reasonable instruction set available.
</p>

<p>
This implementation uses predefined macros of the form
</p>

<p>
<code>__GCC_HAVE_SYNC_COMPARE_AND_SWAP_X</code>
</p>

<p>
where <code>X</code> can be one of 1, 2, 4, 8 or 16. All versions of gcc and
clang since at least ten years implement these macros and the
underlying operations consistently.
</p>

<p>
If that macro exists, we suppose that the compiler is able to
synthesize all corresponding memory functions for types of size <code>X</code>
and all necessary arithmetic function for integer types of that
size, as lock-free (= stateless) instructions.
</p>

<p>
This doesn't mean that there are direct assembler instruction for
all these operations. They can well be implemented as an unbounded
loop that uses a <code>compare_and_swap</code> (CAS) primitive for atomic
exchange. Gcc typically does this for the less common atomic
arithmetic instructions such as <code>atomic_fetch_and</code>, for
example. Lock-free doesn't mean a bounded number of instructions.
</p>

<p>
Relevant for C11 are 9 operations
</p>
<ul class="org-ul">
<li><code>fetch_add</code> for integer and pointer addition, returning the previous value</li>
<li><code>fetch_sub</code> for integer and pointer subtraction, returning the previous value</li>
<li><code>fetch_or</code>  for bitwise or, returning the previous value</li>
<li><code>fetch_and</code> for bitwise and, returning the previous value</li>
<li><code>fetch_xor</code> for bitwise xor, returning the previous value</li>
<li><code>load</code> for an atomic load operation</li>
<li><code>store</code> for an atomic store operation</li>
<li><code>exchange</code> for an atomic exchange operation, equivalent to a
<code>store</code> that returns the previous value</li>
<li><code>compare_exchange</code> for an atomic compare and exchange
operation, equivalent to a conditional <code>store</code> that also saves
the previous value, and returns <code>false</code> or <code>true</code> according to
the success of the condition and the possible <code>store</code>
operation. Two semantically different interfaces are
provided. A <code>strong</code> version that returns <code>false</code> and <code>true</code> as
described, and a <code>weak</code> version that may fail eventually, even
if the condition of equality was fulfilled.</li>
</ul>

<p>
According to recent precision given by the C standards committee
the <code>store</code>, <code>exchange</code> and <code>compare_exchange</code> functions have
memory semantics, that is they are done as-if using <code>memcpy</code> and
<code>memcmp</code> not as-if using equality and assignment operations. This
distinction is important for two cases
</p>

<ul class="org-ul">
<li>If the corresponding type has padding bits or bytes,
<code>compare_exchange</code> can fail even if the abstract value of two
objects would compare equal. This is because the padding, if
different for the objects, enters into the comparison.</li>
<li>Floating point <code>NaN</code> seen as values always compares false, even
if two <code>NaN</code> are compared. When compared as bit pattern through
<code>memcmp</code> they could compare equal.</li>
</ul>

<p>
These operations in C11 generally have two variants, one that uses
sequential consistency and another one where a more detailed
consistency can be requested through additional parameters. So in
total we have to provide 20 different type generic functional
interfaces.
</p>

<p>
For the operations that cannot be mapped to built-in compiler support
the compilers inserts calls to external functions. The names for
these functions are typically composed of the operation and
prefixed either by <code>__sync_</code> (the older gcc ABI) or <code>__atomic_</code>
(the newer gcc ABI). The names of these calls can be suffixed by
<code>_X</code> for <code>X</code> as above if this concerns an operation on a type of
the corresponding width.
</p>

<p>
All external functions that the gcc ABI's require are provided.
</p>
</div>

<div id="outline-container-org45188fa" class="outline-4">
<h4 id="org45188fa"><span class="section-number-4">1.2.1</span> The <code>__atomic_</code> ABI</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
is already close to the C11 call interface as given above.
</p>

<p>
In addition to the more or less obvious operands, the built-in
functions take one or two additional parameters that reflect an
eventual requirement for the <code>memory_order</code> of the operation. So
the functions represent the C11 "explicit" features such as
<code>atomic_fetch_add_explicit</code>. The non-explicit versions have to be
mapped to the explicit version by providing <code>memory_order_seq_cst</code>
as parameter(s).
</p>

<p>
Observe that the built-in functions only foresee one interface
<code>compare_exchange</code>.
</p>

<ul class="org-ul">
<li>The distinction between <code>weak</code> and <code>strong</code> versions of these
built-in functions are ruled through an additional parameter,
not through a different function interface.</li>

<li><p>
The function symbol fall-back <code>__atomic_compare_exchange</code>
confusingly has a different semantic and prototype than the
built-in function. It misses the parameter to chose between the
"weak" and the "strong" version, and solely corresponds to the
C11 operation
</p>

<p>
<code>atomic_compare_exchange_strong_explicit</code>
</p></li>
</ul>

<p>
As said, <code>load</code>, <code>store</code> and <code>compare_exchange</code> operations have
<i>memory</i> semantics. The implementation may use <code>=</code> or <code>==</code> operators
in some places for optimization, but it then does so with objects
of <code>uintXX_t</code>, so every bit is accounted for.
</p>

<p>
Function call interfaces for the arithmetic operations are only
generated if we can suppose that an integer type for the
corresponding size exists. We can reasonably assume that there are
always types <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code> and <code>uint64_t</code>, so
the variants for 1, 2, 4 and 8 can always be generated.
</p>

<p>
For a 128 bit type these are only generated if <code>__SIZEOF_INT128__</code>
or <code>__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16</code> exist. If so, we assume
that <code>__uint128_t</code> is such an integer type and known to the
compiler.
</p>

<p>
Arithmetic operations can safely use these <code>uintXX_t</code> types
internally, since the standard imposes two's complement
representation for signed atomic types and also enforces that
atomic operations may not produce traps on overflow.
</p>

<p>
Additionally to the operations that have generic function
interfaces in the C11 standard, gcc additionally implements six
other built-ins, namely
</p>

<ul class="org-ul">
<li><code>__atomic_add_fetch</code> for integer or pointer addition, returning the updated value</li>
<li><code>__atomic_sub_fetch</code> for integer or pointer subtraction, returning the updated value</li>
<li><code>__atomic_or_fetch</code>  for bitwise or, returning the updated value</li>
<li><code>__atomic_and_fetch</code> for bitwise and, returning the updated value</li>
<li><code>__atomic_xor_fetch</code> for bitwise xor, returning the updated value</li>
<li><code>__atomic_fetch_nand</code> for bitwise nand (<code>x = ~(x &amp; v)</code>), returning the previous value</li>
<li><code>__atomic_nand_fetch</code> for bitwise nand (<code>x = ~(x &amp; v)</code>), returning the
updated value</li>
</ul>

<p>
For the completeness of the library interface we supply analogous
functions with the <code>_X</code> suffix for these. They might be called by
the compiler if the user code uses assign and add or similar
operators on atomic integers.  The <code>__atomic_add_fetch</code> and
<code>__atomic_sub_fetch</code> functions may also eventually be used by the
compiler to implement an atomic prefix increment or decrement
operation (<code>++x</code> and <code>--x</code>). This would e.g happen if <code>x</code> is an
object of type <code>__int128_t</code> and the platform doesn't implement
lock-free atomics for types of size 16.
</p>
</div>
</div>

<div id="outline-container-org766a4c8" class="outline-4">
<h4 id="org766a4c8"><span class="section-number-4">1.2.2</span> Clang's <code>__c11_atomic</code> built-ins</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Clang has gone a different path for the built-ins that implement
C11 atomics, prefixed with <code>__c11_atomic</code>. These are a directly
feature equivalent to the C11 generic functions that have
<code>memory_order</code> arguments (<code>_explicit</code> suffix).
</p>

<p>
For the cases that no atomic instructions can be synthesized,
clang falls back to the same external calls as described for gcc's
<code>__atomic</code> ABI.
</p>
</div>
</div>


<div id="outline-container-org3e7c0bc" class="outline-4">
<h4 id="org3e7c0bc"><span class="section-number-4">1.2.3</span> The <code>__sync</code> ABI</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
It dates back long before the C11 atomic interface had been
designed and thus cannot be directly conforming to it. It has
basically the same built-ins for arithmetic types as above, only
that
</p>

<ul class="org-ul">
<li>The functions are named a bit differently.</li>
<li>They only implement sequential consistency.</li>
<li>There are no <code>load</code>, <code>store</code> or <code>exchange</code> features.</li>
<li>The <code>nand</code> operations changed their meaning from version 4.4
onward. Therefore this operation cannot be used portably in an
environment that might use different versions of compilers. So
we don't implement these function interfaces and we deprecate
the use of this built-in.</li>
</ul>

<p>
Additionally this interface also implements a <code>test_and_set</code>
functionality that is used to implement the <code>atomic_flag</code>
functions. This built-in is documented to have acquire-release
consistency. If used with sequential consistency, an additional
fence is inserted to ensure that.
</p>

<p>
These features are sufficient to provide a decent implementation of
C11 atomics.
</p>
</div>
</div>

<div id="outline-container-org4061aec" class="outline-4">
<h4 id="org4061aec"><span class="section-number-4">1.2.4</span> The lock-full fallback functions</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
In absence of proper architecture support, all fallbacks (for
the three built-in families) with <code>_X</code> suffix use the ones without
suffix underneath. These external interfaces receive the size of
the data type as an additional, leading parameter:
</p>

<ul class="org-ul">
<li><code>__atomic_load</code></li>
<li><code>__atomic_store</code></li>
<li><code>__atomic_exchange</code></li>
<li><code>__atomic_compare_exchange</code></li>
</ul>

<p>
They have pure memory semantics and their basic operations are
<code>memcpy</code> and <code>memcmp</code> for load, store and comparison.
</p>

<p>
These functions <b>cannot be called directly</b> from within your code,
because the compiler cannot distinguish them from the gcc built-ins,
<i>and</i> they have different prototypes than these.
</p>

<p>
We implement these functions as critical sections that are
protected with a lock, similar to a mutex. This implementations
uses a table of locks and a hash function to choose one of the
entries that only depends on the address of the atomic object.
</p>

<p>
At the moment, this implementation has several address-hash
functions that can be chosen a library-compile time. Any function
that mixes the bits of the address should perform reasonably well.
</p>

<p>
More important for performance is the choice of the lock. Such a
lock can be relatively simple, since C11 atomics that are not
lock-free don't have to be asynchronous signal safe.
</p>

<p>
There are several possibilities, in order of preference:
</p>

<ul class="org-ul">
<li>An OS specific light-weighted lock with non-active waits. The
integration into <code>musl</code> uses Linux' <code>futex</code> underneath to do an
efficient wait. If by coincidence these are called in an
un-threaded process, they are close to non-ops.</li>

<li>C11's <code>mtx_t</code> type has an shallow interface that should allow
it to be implemented a bit simpler and efficient than OS
specific mutexes that implement a lot of functionality. This
solution should be portable to all platforms that implement
this part of C11. In a relatively near future these could be
all POSIX and Windows platforms. This approach has the
disadvantage that a table of <code>mtx_t</code> must be initialized at
process startup because <code>mtx_t</code> doesn't guarantee static
initialization.</li>

<li>POSIX' <code>pthread_mutex_t</code> is a little less portable, but allows
for static initialization.</li>

<li><p>
A spinlock similar to <code>atomic_flag</code>. Such an approach is
portable to all platforms that implement atomics and allows for
static initialization. This is the only choice when compiled
without OS or library support.
</p>

<p>
The wait functionality is an active wait, that burns CPU cycles
and memory bandwidth. In many circumstances this should do
well, the critical sections that are protected by this are nice
and small.
</p></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org83eb2c0" class="outline-2">
<h2 id="org83eb2c0"><span class="section-number-2">2</span> The <code>&lt;stdatomic.h&gt;</code> header file</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-org984beae" class="outline-3">
<h3 id="org984beae"><span class="section-number-3">2.1</span> Full C11 support</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Versions of gcc and clang that fully implement the C11 atomics
interface will not need a special header file but can use their own
that is shipped with the compiler:
</p>

<ul class="org-ul">
<li>gcc starting with version 4.9</li>

<li>clang starting with version 3.6</li>
</ul>

<p>
This full support of atomics allows to use atomic objects just as
other objects it whatever operations the base type supports.
</p>

<p>
These default operations on atomics use sequential consistency. That
is, each such an operation will enforce a full memory transfer and
the perceived effect is as if all these operations, even if issued
in different threads, have been done one after another. Thus, thread
parallelism can only play between such operations:
</p>

<div class="org-center">
<p>
<b>atomics operations are expensive</b>
</p>
</div>

<p>
The functional interfaces with different <code>memory_order</code> arguments
(<code>_explicit</code> suffix to the name) that we described above may be used
to milder the memory effect that atomic operations have. The
possible gain of such different memory consistency models are very
architecture dependent. E.g on the x86 platforms they offer almost
no advantage, whereas on ARM platforms acquire/release semantics may
bring some noticeable gain.
</p>

<p>
But beware that this gain is bought with a sensible complexification
of the code. Only use this if the atomic operations are a measurable
performance bottleneck <i>and</i> you already have reduced the number of
these operations to a minimum.
</p>
</div>
</div>

<div id="outline-container-org2bd715e" class="outline-3">
<h3 id="org2bd715e"><span class="section-number-3">2.2</span> Partial C11 atomics support</h3>
<div class="outline-text-3" id="text-2-2">
<p>
A series of compiler versions offers partial atomics support that
already implements most of the C11 semantic:
</p>

<ul class="org-ul">
<li>gcc versions 4.7 and 4.8</li>

<li>clang versions 3.2 to 3.5</li>
</ul>

<p>
These versions provide the built-in functions as described above but
lack full compiler support for atomic types and operations.
</p>

<p>
With the <code>&lt;stdatomic.h&gt;</code> header that we supply for these compilers,
application code can use the functional interfaces. A macro
<code>_Atomic(T)</code> is provided that can be used to issue emulated
declarations of atomic types that should be <b>forward compatible</b> to
platforms with complete C11 atomics support.  Example:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #66cdaa;">// </span><span style="color: #66cdaa;">global variables</span>
_Atomic(size_t) thread_inside_count = ATOMIC_VAR_INIT(0);
_Atomic(size_t) thread_total_count = ATOMIC_VAR_INIT(1);

<span style="color: #9290ff;">int</span> <span style="color: #0000ee;">my_thread_function</span>(<span style="color: #9290ff;">void</span>* <span style="color: #006400;">arg</span>) {
   atomic_fetch_add(&amp;thread_inside_count, 1);
   atomic_fetch_add(&amp;thread_total_count, 1);

   <span style="color: #66cdaa;">// </span><span style="color: #66cdaa;">do something complicated here</span>

   <span style="color: #66cdaa;">// </span><span style="color: #66cdaa;">at the end</span>
   atomic_fetch_sub(&amp;thread_inside_count, 1);
}
</pre>
</div>

<p>
Underneath such emulated atomic objects are implemented as arrays of
<code>volatile</code> base type of size 1. This has the following sought
effects:
</p>

<ul class="org-ul">
<li>They can't be assigned to.</li>
<li>They evaluate to a pointer in almost any context.</li>
<li>Operations with them cannot be reordered by the compiler.</li>
</ul>

<p>
So you should be relatively safe from programming errors that would
access such objects without passing through the type generic atomic
functions. The compiler will error out on improper usage of such
atomic objects, but the diagnostics may be a bit crude.
</p>
</div>

<div id="outline-container-org9d2a801" class="outline-4">
<h4 id="org9d2a801"><span class="section-number-4">2.2.1</span> Issues</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Since this approach may reinterpret data through pointer casts, it
could potentially be dangerous. So let us discuss the possible
issues.
</p>

<ul class="org-ul">
<li>The generic fallbacks for memory access only use <code>memcpy</code> and
<code>memcmp</code> to access the data itself. So the access of the data is
within the constraints of the standard.</li>

<li>The generic fallbacks for memory access ensure that their
arguments have compatible base types (if a pointer is passed in)
or are assignment compatible with the base type of the atomic
(if a value is passed in). So data that is copied across can
never be misinterpreted as being of a wrong type because the two
target types are compatible.</li>

<li>The specialized functions with <code>_X</code> suffix may reinterpret their
data as the corresponding <code>uintXX_t</code> for the size. Copying or
comparing such data is always guaranteed to use all bits, so in
that sense it is equivalent to <code>memcpy</code> and <code>memcmp</code>.</li>

<li>The arithmetic operations that are executed then are operations
on an unsigned integer type that has no padding bits. This
arithmetic is compatible for all integer types that have no
padding bits and, for the signed types, are represented with
two's complement.</li>

<li>An emulated atomic with this approach is implemented as an array
to the base type, and so in the user code the base type of the
object remains visible to the compiler. As a consequence this
approach has no effect on the aliasing rules, the compiler
always has complete information about the type of each object.</li>
</ul>

<p>
The only potential problem for our approach that remains is
alignment. Since the stub functions that are provided may use
casts to <code>uintXX_t</code> of "atomic" objects you have to ensure that
these objects are at least aligned as these types would be. This
should not be a problem, if the base type is an integer type,
too. Integer types with same size should have the same alignment.
</p>

<p>
If you encounter problems with a user defined type that has a size
that is a small power of two you could force alignment
</p>

<div class="org-src-container">
<pre class="src src-C">_Alignas(<span style="color: #6495ed; font-weight: bold;">sizeof</span>(toto)) _Atomic(toto) toto1;
<span style="color: #6495ed; font-weight: bold;">__attribute__</span>((__aligned__(<span style="color: #6495ed; font-weight: bold;">sizeof</span>(toto)))) <span style="color: #0000ee;">_Atomic</span>(toto) toto2;
</pre>
</div>

<p>
with whatever of the two constructs works for you.
</p>

<p>
I am currently struggling to provide a version of the <code>_Atomic(T)</code>
macro that ensures that automatically. It seems to be possible but
produces a lot of noise for function parameters that are pointers
to atomics.
</p>
</div>
</div>
</div>

<div id="outline-container-org073982d" class="outline-3">
<h3 id="org073982d"><span class="section-number-3">2.3</span> Basic atomics support</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Even older versions of gcc and clang implement the <code>__sync</code> built-in
functions and can thereby made to accept the same &lt;stdatomic.h&gt;
header as discussed above. Since, as their names indicate, these
built-ins only have fully synchronizing versions, they will not be
able to take advantage of the different consistency models. But
implementing atomics with stronger consistency than required, here
sequential consistency, only, is conforming to the C standard.
</p>
</div>
</div>
</div>

<div id="outline-container-orge20f3b4" class="outline-2">
<h2 id="orge20f3b4"><span class="section-number-2">3</span> The implementation</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-org6e1eb2b" class="outline-3">
<h3 id="org6e1eb2b"><span class="section-number-3">3.1</span> Requirements</h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-orgb247dbc" class="outline-4">
<h4 id="orgb247dbc"><span class="section-number-4">3.1.1</span> Compilers</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
You should be able to compile this implementation with any version
of modern gcc and clang. (Versions are hard to tell, gcc should work
for 4.1) The quality of the resulting binary will depend on the
implementation of atomic support by the compiler.
</p>

<p>
There are three different implementations, for modern clang and gcc,
and one for those compilers that only support the <code>__sync_</code>
built-ins. They are only tested with clang and gcc, but might work
with other compilers that implement one of the sets of built-ins and
is otherwise compatible to some gcc extensions:
</p>

<ul class="org-ul">
<li>compound expressions with <code>({ })</code></li>
<li><code>__typeof__</code></li>
<li><code>__attribute__((__unused__))</code></li>
<li><code>__builtin_choose_expr</code> for the <code>__sync</code> version as a precursor of
C11's <code>_Generic</code></li>
<li><code>#pragma redefine_extname</code> to rename the external symbols that are produced</li>
</ul>

<p>
If aligment happens to be an issue you might also need
</p>

<ul class="org-ul">
<li><code>__attribute__((__aligned__(something)))</code></li>
<li><code>__alignof__</code></li>
</ul>

<p>
or the equivalent C11 features <code>_Alignas</code> and <code>_Alignof</code>.
</p>

<p>
There are some heuristics in place to decide at compile time which
case applies, namely <code>__clang__</code> to detect clang, <code>__ATOMIC_...</code>
macros to detect the C11 versions of the built-ins.
</p>
</div>
</div>

<div id="outline-container-org925280b" class="outline-4">
<h4 id="org925280b"><span class="section-number-4">3.1.2</span> OS or C library support</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The library may work with different lock constructs, as described
above, that is a futex based support for Linux, C11's <code>mtx_t</code>,
POSIX' <code>pthread_mutex_t</code>, and active spinning as a last
resort. You may find a description of the algorithms and some
performance figures in the article
<a href="https://hal.inria.fr/hal-01236734">https://hal.inria.fr/hal-01236734</a>
</p>

<p>
If you would like to see support for other OS or runtime
environments, don't hesitate to contact me if you'd like to work
on implementing and integrating this.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfcc19af" class="outline-3">
<h3 id="orgfcc19af"><span class="section-number-3">3.2</span> Caveats</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-org8bf8447" class="outline-4">
<h4 id="org8bf8447"><span class="section-number-4">3.2.1</span> Symbol renaming</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
There is one important difficulty when compiling this. The original
<code>__atomic</code> library interface was developed with C++ in mind and not
C. Therefore it freely uses function overloading for the built-ins
versus the library interface. Since we also use the library
functions as fallbacks in the implementation of some of the <code>_X</code>
variants this naming scheme is not supportable with a C compiler.
</p>

<p>
We get away with it by using internal names, prefixed with <code>__impl_</code>
for all functions. Then a gcc extension is used to map that internal
name to an external name, e.g
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #6495ed;">#pragma</span> redefine_extname __impl_load __atomic_load
</pre>
</div>

<p>
If your compiler doesn't support this feature, you'd have to use an
external tool such as <code>objcopy</code> to achieve the same.
</p>
</div>
</div>

<div id="outline-container-org3b3847e" class="outline-4">
<h4 id="org3b3847e"><span class="section-number-4">3.2.2</span> Support of 16 byte atomic instructions</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
The main difference for modern processors that is relevant here is
if it supports 16 byte atomic instructions or not. There is no
difficulty to detect this at compile time, but if the library is
used with code that is compiled with a different compiler or just
different compiler options, incompatible binary code may be
produced.
</p>

<p>
My plan is to freeze that feature at compile time of the library
and reflect the capacity in the <code>&lt;stdatomic.h&gt;</code> that is
provided. This then may result in code that is a bit less
optimized than it could, but that is compatible.
</p>

<ul class="org-ul">
<li>If the library is <b>not</b> compiled with direct 16 byte support the
application may not use it, and thus use a memory implementation
for such operations.</li>

<li>If the library <b>is</b> compiled with direct 16 byte support but the
application compiler doesn't support it, the user code should
fallback to library calls, but which in turn use the atomic
instructions. So such a variant would have a call overhead and
would not be able to inline the atomics in the user binary.</li>
</ul>

<p>
I already have a working implementation of such a safety feature
in some other code, so this is feasible. But for the moment this
is not yet done, here. Be careful when using this preliminary
version.
</p>
</div>
</div>
</div>


<div id="outline-container-org4471767" class="outline-3">
<h3 id="org4471767"><span class="section-number-3">3.3</span> Leftovers</h3>
<div class="outline-text-3" id="text-3-3">
<p>
There are some leftovers that will hopefully disappear.
</p>

<ul class="org-ul">
<li>There are several hash functions and a instrumentation
infrastructure for the hashes. I didn't have enough test cases
yet to see what would be best, here.</li>
</ul>
</div>
</div>

<div id="outline-container-org3ba7905" class="outline-3">
<h3 id="org3ba7905"><span class="section-number-3">3.4</span> Instrumentation and testing</h3>
<div class="outline-text-3" id="text-3-4">
</div><div id="outline-container-org2c0cb70" class="outline-4">
<h4 id="org2c0cb70"><span class="section-number-4">3.4.1</span> Instrumentation</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
There is optional instrumentation for the lock
functions. Switching it on changes overall performance
substantially, and thus I'd expect a noticeable effect by the observation
principle. These counters can give qualitative information about
what happens, but you shouldn't take the figures verbally. Also these
counters are only protected if you test the library with only one
lock, using atomics for these counters themselves would have a
strong performance impact and the resulting statistics would
basically be worthless.
</p>

<p>
You can switch the instrumentation of the code on by defining the
symbol <code>BENCH</code> at compile time. A function <code>atomic_summary</code> can be
used at the end of all operations to print the collected data to
<code>stderr</code>.
</p>
</div>
</div>

<div id="outline-container-org6551fc4" class="outline-4">
<h4 id="org6551fc4"><span class="section-number-4">3.4.2</span> Code injection</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
To test the behavior of the locking algorithm you may inject a
function call just after the acquisition of the lock. Thereby you
can e.g force the thread that obtains the lock to be descheduled,
and test the worst-case behavior of the locking algorithm.
</p>

<p>
This feature is switched on by defining the macro <code>ATOMIC_INJECT</code>
at compile time. By that you have a thread local variable
<code>atomic_faulty</code> and a function interface <code>atomic_inject</code> at your
disposal, namely <code>atomic_inject</code> is called iff <code>atomic_faulty</code> is
true for the calling thread.
</p>

<p>
There is a "weak" version of <code>atomic_inject</code> that does nothing. It
can be overwritten by a specific version that you provide
yourself. E.g for the benchmarks using
<a href="http://cmod.gforge.inria.fr/">Modular C</a> in the
<a href="https://hal.inria.fr/hal-01236734">article</a> that we mentionned
above, slow path of the algorithm is stressed by simply calling
<code>thrd_yield</code>.
</p>

<p>
The variable <code>atomic_faulty</code> can be used to switch the code
injection on and off, such that you may experiment with different
probabilities of failure.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc15658d" class="outline-2">
<h2 id="orgc15658d"><span class="section-number-2">4</span> Performance considerations</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-orgeb79bad" class="outline-3">
<h3 id="orgeb79bad"><span class="section-number-3">4.1</span> Benchmarks</h3>
<div class="outline-text-3" id="text-4-1">
<p>
I have run a long series of benchmarks to validate the
approach. The code for the benchmark is at the moment integrated in
<i>p11</i> with comes with <i>Modular C</i>, see
<a href="http://cmod.gforge.inria.fr/">Cmod</a>. To compile it you'd need
</p>

<ul class="org-ul">
<li>a C11 compliant library that has C11 threads, I only know of
<a href="http://www.muls-libc.org/">musl</a>, or an implementation of
POSIX' threads that can be used to emulate C11 threads.</li>
<li>a C11 compiler that also has gcc extension. I tested with gcc and
clang.</li>
<li><a href="http://cmod.gforge.inria.fr/">Cmod</a></li>
<li><a href="http://p99.gforge.inria.fr/">P99</a>, my old macro library. This one
could probably avoided, it is just needed for some parts of p11.</li>
</ul>

<p>
The test in p11 is called p11#test#lifo. It is based on a stack
implementation (Last In First Out) that uses an atomic pair of
items for the head to avoid the ABA problem.
</p>

<p>
Please refer to the <a href="https://hal.inria.fr/hal-01236734">article</a>
for some results of the benchmarks.
</p>
</div>
</div>

<div id="outline-container-orgc872799" class="outline-3">
<h3 id="orgc872799"><span class="section-number-3">4.2</span> Code inspection</h3>
<div class="outline-text-3" id="text-4-2">
</div><div id="outline-container-orgf939df7" class="outline-4">
<h4 id="orgf939df7"><span class="section-number-4">4.2.1</span> Lower range of thread numbers</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
For this application the performance in the lower range of is
largely dominated by the fast path, that is by a very small number
of assembler instructions that constitute the good case, when a
thread doesn't encounter congestion. On a <code>x86_64</code> machine, our
implementation of the four different categories result in the
following memory instructions:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">lock</th>
<th scope="col" class="org-left">unlock</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">spinlock</td>
<td class="org-left"><code>cmpxchgl</code></td>
<td class="org-left"><code>movl</code></td>
</tr>

<tr>
<td class="org-left">futex</td>
<td class="org-left"><code>cmpxchgl</code></td>
<td class="org-left"><code>lock addl</code></td>
</tr>

<tr>
<td class="org-left">mutex</td>
<td class="org-left"><code>cmpxchgl</code></td>
<td class="org-left"><code>movl</code>, <code>xchg</code></td>
</tr>

<tr>
<td class="org-left">musl</td>
<td class="org-left"><code>xchg</code></td>
<td class="org-left"><code>movl</code>, <code>mov</code>, <code>lock orl</code>, <code>mov</code></td>
</tr>
</tbody>
</table>

<p>
The spinlock and futex implementation here have very similar
performance, because they have a minimal number memory
instructions.
</p>

<p>
Musl's internal lock implementation actually looses for the
unlock. It has four different memory instructions. Two of them
originate from the internal macro <code>a_store</code>, which needs a
synchronization of the <code>mov</code> instruction to avoid reordering on
the processor. It results in two instructions:
</p>

<div class="org-src-container">
<pre class="src src-[x86masm]Assembler">mov eax, (%rdi)
lock orl (%rsp)
</pre>
</div>

<p>
We observed an improvement whe <code>a_store</code> is implemented directly
with on atomic instruction, e.g.
</p>

<div class="org-src-container">
<pre class="src src-[x86masm]Assembler">xchg %eax, (%rdi)
</pre>
</div>

<p>
Such a change could perhaps be integrated into musl at a later
stage.
</p>

<p>
The mutex implementations have two memory instructions for the
unlock functions. One <code>movl</code> from memory to CPU for a waiters
counter, and one <code>xchg</code> to manipulate the lock itself.
</p>

<p>
Our implementation attempts to combine the two instructions for
unlock into one: on the fast path we only need one atomic
addition. By that we are better than the mutex, we save one
<code>movl</code> instruction for the waiters counter. We may be a bit
worse than the spinlock, because that only has a write to memory
to perform, and doesn't need information from memory to be
returned to the CPU.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org2a1e813" class="outline-2">
<h2 id="org2a1e813"><span class="section-number-2">5</span> Installation</h2>
<div class="outline-text-2" id="text-5">
<p>
As said above it will be important that your compiled library and
your user code agree on the model of the atomics that they have for
16-byte data types. Be careful, compiler options that change the
processor model can change this characteristic, e.g if you compile
with <code>gcc</code> and the option <code>-march=native</code>.
</p>

<p>
If your compiler (<code>gcc</code> or <code>clang</code>) already has a working
<code>stdatomic.h</code> file in place, you have nothing to do from that
part. If not, you should install all files of the form
</p>

<p>
<code>atomic_.....h</code>
</p>

<p>
in an include directory where your compiler can find it when you
compile application code.
</p>
</div>

<div id="outline-container-org37ba3d9" class="outline-3">
<h3 id="org37ba3d9"><span class="section-number-3">5.1</span> Musl</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-org1904c1b" class="outline-4">
<h4 id="org1904c1b"><span class="section-number-4">5.1.1</span> direct integration</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
If you have the sources of musl the easiest is to integrate the
library directly into the libc. To achieve that just do
</p>

<div class="org-src-container">
<pre class="src src-sh">make <span style="color: #006400;">MUSL</span>=your/path/to/musl musl
</pre>
</div>

<p>
This copies all necessary code to a subdirectory of your musl
path. Then just compile and install musl as you would do usually.
</p>

<p>
By default this chooses the <code>futex</code> implementation of the generic
lock function.
</p>
</div>
</div>

<div id="outline-container-org5176ff3" class="outline-4">
<h4 id="org5176ff3"><span class="section-number-4">5.1.2</span> building externally</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
If you want to compile a standalone <code>libstdatomic.a</code> library archive
file, you first need to compile one object file that encapsulates
all system calls to <code>futex</code>. This can be done with the same command
as above
</p>

<div class="org-src-container">
<pre class="src src-sh">make <span style="color: #006400;">MUSL</span>=your/path/to/musl musl
</pre>
</div>

<p>
and then
</p>

<div class="org-src-container">
<pre class="src src-sh">make <span style="color: #006400;">MUSL</span>=your/path/to/musl libstdatomic.a
</pre>
</div>

<p>
This will compile the one file inside the musl <code>src</code> hierarchy and
then assemble all to one "standalone" library.
</p>
</div>
</div>
</div>

<div id="outline-container-org9a45e07" class="outline-3">
<h3 id="org9a45e07"><span class="section-number-3">5.2</span> Other C libraries</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Up to now I only tested with <code>glibc</code> as other C library. If you
have experience with other libraries please let me know.
</p>

<p>
For the moment the <code>futex</code> generic lock only works with musl, so
you have to chose another one when musl is not available. You
choose the version through a define of <code>ATOMIC_GENERIC_LOCK</code>:
</p>

<dl class="org-dl">
<dt><code>ATOMIC_GENERIC_LOCK_PTHREAD</code></dt><dd>uses a <code>pthread_mutex_t</code> for the
lock. It will be the choice for most, unless you have a C
library that already implements C11 threads, then you'd use</dd>

<dt><code>ATOMIC_GENERIC_LOCK_MTX</code></dt><dd>and a <code>mtx_t</code>.</dd>

<dt><code>ATOMIC_GENERIC_LOCK_CMPXCHG</code></dt><dd>is the last resort if you have
neither of the two above. This implements just a spinlock. It
is only suited for applications that don't have a strong
congestion on any atomic operation. If there is a lot of
congestion, the application will suffer dramatically.</dd>
</dl>

<p>
With this choice, you may compile the library with a simple <code>make</code>
</p>

<div class="org-src-container">
<pre class="src src-sh">make <span style="color: #006400;">CONFIG</span>=<span style="color: #32cd32;">'-DATOMIC_GENERIC_LOCK=ATOMIC_GENERIC_LOCK_PTHREAD'</span> libatomic.a
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org9596efb" class="outline-2">
<h2 id="org9596efb"><span class="section-number-2">6</span> Terms</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-orgb720cba" class="outline-3">
<h3 id="orgb720cba"><span class="section-number-3">6.1</span> Copyright and License</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">
<pre class="src src-txt">The stdatomic library as a whole is licensed under the following standard MIT license:

----------------------------------------------------------------------
Copyright  2015-2017 Jens Gustedt

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
----------------------------------------------------------------------
</pre>
</div>
</div>
</div>

<div id="outline-container-org5a61a26" class="outline-3">
<h3 id="org5a61a26"><span class="section-number-3">6.2</span> Distribution</h3>
<div class="outline-text-3" id="text-6-2">
<p>
This work is distributed at <a href="http://stdatomic.gforge.inria.fr/"><a href="http://stdatomic.gforge.inria.fr/">http://stdatomic.gforge.inria.fr/</a></a>.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jens Gustedt</p>
<p class="date">Created: 2017-10-02 Mo 17:45</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
